#多继承：一个类可以继承于多个父类，比如，骡子，它有驴和马的特性

#重写：在子类中，定义了一个函数名function()跟父类中的函数名function()相同时，这个子类就重写了父类的function()函数

#子类重写了父类方法，但又有需要再调用父类方法。在子类中调用父类方法有三种方式调用方式
class A(object):
    def __init__(self, name):
        self.name = name



class B(A):
    def __init__(self, name, age):  # 此时重写了父类的__init__方法，在调用B的实例时，自动执行的是B中的__init__()方法
        # 在子类中调用父类的方法，有以下三种：
        #（子类中调用父类的方法作用：让子类中也拥有self.name属性）

        # 1、父类名调用__init__()方法
        A.__init__(self, name)  # 注意：第一次实参必须是self
        # 2、super()返回父类对象再调用__init__()方法
        super().__init__(name)
        # 3、super返回指定父类对象再调用__init__()方法
        super(A, self).__init__(name)
        # super() 参数1：指定当前类名，参数2：当前类对象slef
        # 说明
        #   参数1是将当前类名替换为指定的类名(参数1)，再根据__mro__去寻找参数1的父级类名，最后返回该指定类名的父类名对象
        #   由此super()方法可以自由设定返回的父类对象
        self.age = age


#面试题：解释super()的用法
#   在python3中，当有多继承时，会经常出现使用super()调用父类而调用不了的情况，为什么会出现这种情况呢？
#   因为python中有一种专门处理多继承调用父类先后顺序的算法，这种算法叫C3算法，它是保证每个类都调用一次的算法
#   C3算法的体现在于打印最低层孙子类的类目的__mro__属性，会看到C3算法的结论，这个结论是一个元组
#   元组中存放的是所有类的名字，类名字的先后顺序决定了将来调用super()返回父类对象的先后顺序，
#   判断标准是，如果super()不传参数，就拿当前类的类目去元组中去找，找到了这个类名后，它的下一个类名，就是super()返回的父类对象
#   随后就可以调用这个父类中的方法了。和super()传参数的不同，在于super()可以传入当前类所继承的所有父类名，指定的父类名再去__mro__找，找到之后的下一个，就是super的返回对象，即传参可以指定super()返回的父类对象


#优缺点总结
#   父类名调用父类函数
#       优点：明确调用哪个父类
#       缺点：会造成爷爷类的多次调用
#   super()不传参
#       优点：保证每个类只被调用一次
#       缺点：不明确调用哪个父类
#   super()传参
#       优点：可以自由指定父类对象
#       缺点：不明确调用哪个父类